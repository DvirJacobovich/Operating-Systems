////////////////////////////////////////////////////////////////////////////////////////////

//void thirdReducing(pthread_context *curr_thread)
//{
//    if (curr_thread->shuffledVectors->empty() &&
//        curr_thread->sortedVectors->empty())
//    {
//        curr_thread->doneShuffle = true;
//        for (int i = 0; i < curr_thread->numOfThreads; ++i)
//        {
//            sem_post(curr_thread->shuffledSem);
//        }
//    }
//    while (!curr_thread->doneShuffle)
//    {
//        sem_wait(curr_thread->shuffledSem);
//        pthread_mutex_lock(curr_thread->shuffledMutex);
//        if (curr_thread->shuffledVectors->empty())
//        {
//            pthread_mutex_unlock(curr_thread->shuffledMutex);
//            break;
//        }
//        IntermediateVec reduceVec = curr_thread->shuffledVectors->back();
//        curr_thread->shuffledVectors->pop_back();
//        pthread_mutex_unlock(curr_thread->shuffledMutex);
//        curr_thread->client->reduce(&reduceVec, curr_thread);
//        sem_post(curr_thread->shuffledSem);
//    }
//}
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
//void secondReducing(pthread_context* curr_thread)
//{
//    while (!(curr_thread->doneShuffle && curr_thread->shuffledVectors->empty()))
//    {
//        if (sem_wait(curr_thread->shuffledSem))
//        {
//            exit(1);
//        }
//
//        if (!(curr_thread->doneShuffle && curr_thread->shuffledVectors->empty()))
//        {
//            IntermediateVec reduceVec;
//            int sign = 0;
//
//            pthread_mutex_lock(curr_thread->shuffledMutex);
//            if (!curr_thread->shuffledVectors->empty())
//            {
//                 sign = 1;
//                 reduceVec = curr_thread->shuffledVectors->back();
////               sem_wait(curr_thread->shuffledSem);
//                 curr_thread->shuffledVectors->pop_back();
//            }
//
//
//            pthread_mutex_unlock(curr_thread->shuffledMutex);
//
//            pthread_mutex_lock(curr_thread->percentageMutex);
//            curr_thread->reduceCounter++;
//            curr_thread->curr_state->percentage = static_cast<float>((curr_thread->reduceCounter / *curr_thread->sortedSize) * 100.0);
//            if (sign)
//            {
//                curr_thread->client->reduce(&reduceVec, curr_thread);
//
//            }
//            pthread_mutex_unlock(curr_thread->percentageMutex);
//        }
//    }
//
//    unsigned int old_value = (curr_thread->firstToArrive)++;
//    if (!(old_value))
//    {
//        for(int i = 0; i < curr_thread->numOfThreads; ++i)
//        {
//            if (sem_post(curr_thread->shuffledSem))
//            {
//                exit(1);
//            }
//        }
//    }
//
//
//}
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//void reducing(pthread_context *curr_thread)
//{
//
//        if (curr_thread->shuffledVectors->empty() && !curr_thread->doneShuffle)
//        {
//            sem_wait(curr_thread->shuffledSem);
//        }
//
//
//        while (!curr_thread->shuffledVectors->empty())
//        {
//            pthread_mutex_lock(curr_thread->shuffledMutex);
//            IntermediateVec reduceVec = curr_thread->shuffledVectors->back();
//            curr_thread->shuffledVectors->pop_back();
//            pthread_mutex_unlock(curr_thread->shuffledMutex);
//
//            pthread_mutex_lock(curr_thread->percentageMutex);
//            curr_thread->reduceCounter++;
//            curr_thread->curr_state->percentage = static_cast<float>((curr_thread->reduceCounter / *curr_thread->sortedSize) * 100.0);
//            pthread_mutex_unlock(curr_thread->percentageMutex);
//            curr_thread->client->reduce(&reduceVec, curr_thread);
//            if (curr_thread->shuffledVectors->empty() && !curr_thread->doneShuffle) // tring while(true) with conditions.
//            {
//                sem_wait(curr_thread->shuffledSem);
//            }
//
//        }
//
//         unsigned int old_value = (curr_thread->firstToArrive)++;
//             if (!(old_value))
//             {
//                 for(int i = 0; i < curr_thread->numOfThreads; ++i)
//                 {
//                    if (sem_post(curr_thread->shuffledSem))
//                    {
//                        exit(1);
//                    }
//                 }
//            }
//
//}

